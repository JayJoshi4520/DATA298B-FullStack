#!/usr/bin/env python3
"""
Script to create an image classification project structure using PyTorch.
Generated by CodeWriterAgent
"""
import os
import json
from pathlib import Path

def main():
    base_path = "/home/coder/project/"
    project_name = "image_classifier"
    project_path = os.path.join(base_path, project_name)

    try:
        print(f"Creating project at: {project_path}")
        os.makedirs(project_path, exist_ok=True)

        # Create data directory and README
        data_dir = os.path.join(project_path, "data")
        os.makedirs(data_dir, exist_ok=True)
        print(f"✓ Created directory: {data_dir}")

        data_readme_path = os.path.join(data_dir, "README.md")
        data_readme_content = """
# Data Directory

This directory should contain your image data.  Organize your data into subdirectories,
where each subdirectory represents a class.

Example:

```
data/
├── cat/
│   ├── cat_image_1.jpg
│   ├── cat_image_2.jpg
│   └── ...
├── dog/
│   ├── dog_image_1.jpg
│   ├── dog_image_2.jpg
│   └── ...
└── ...
```
"""
        try:
            with open(data_readme_path, "w") as f:
                f.write(data_readme_content)
            print(f"✓ Created file: {data_readme_path}")
        except Exception as e:
            print(f"✗ Error creating {data_readme_path}: {e}")
            return False

        # Create src directory and files
        src_dir = os.path.join(project_path, "src")
        os.makedirs(src_dir, exist_ok=True)
        print(f"✓ Created directory: {src_dir}")

        # Create model.py
        model_path = os.path.join(src_dir, "model.py")
        model_content = """
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self, num_classes=2):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 6, 5)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.fc1 = nn.Linear(16 * 5 * 5, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, num_classes)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16 * 5 * 5)
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x
"""
        try:
            with open(model_path, "w") as f:
                f.write(model_content)
            print(f"✓ Created file: {model_path}")
        except Exception as e:
            print(f"✗ Error creating {model_path}: {e}")
            return False

        # Create dataset.py
        dataset_path = os.path.join(src_dir, "dataset.py")
        dataset_content = """
import torch
from torch.utils.data import Dataset
from PIL import Image
import os

class ImageDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data_dir = data_dir
        self.image_paths = []
        self.labels = []
        self.transform = transform

        classes = os.listdir(data_dir)
        self.class_to_idx = {c: i for i, c in enumerate(classes)}

        for class_name in classes:
            class_dir = os.path.join(data_dir, class_name)
            for image_name in os.listdir(class_dir):
                image_path = os.path.join(class_dir, image_name)
                self.image_paths.append(image_path)
                self.labels.append(self.class_to_idx[class_name])

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, self, idx):
        image_path = self.image_paths[idx]
        image = Image.open(image_path).convert('RGB')  # Ensure RGB
        label = self.labels[idx]

        if self.transform:
            image = self.transform(image)

        return image, label
"""
        try:
            with open(dataset_path, "w") as f:
                f.write(dataset_content)
            print(f"✓ Created file: {dataset_path}")
        except Exception as e:
            print(f"✗ Error creating {dataset_path}: {e}")
            return False

        # Create train.py
        train_path = os.path.join(src_dir, "train.py")
        train_content = """
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import transforms
from torch.utils.data import DataLoader
from src.dataset import ImageDataset
from src.model import SimpleCNN

# Define data transformations
transform = transforms.Compose([
    transforms.Resize((64, 64)),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

# Load the dataset
data_dir = 'data'  # Path to your data directory
dataset = ImageDataset(data_dir, transform=transform)
dataloader = DataLoader(dataset, batch_size=4, shuffle=True)

# Instantiate the model
num_classes = len(dataset.class_to_idx)
model = SimpleCNN(num_classes=num_classes)

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
num_epochs = 2
for epoch in range(num_epochs):
    for i, (images, labels) in enumerate(dataloader):
        # Zero the parameter gradients
        optimizer.zero_grad()

        # Forward pass
        outputs = model(images)
        loss = criterion(outputs, labels)

        # Backward and optimize
        loss.backward()
        optimizer.step()

        if (i+1) % 10 == 0:
            print(f'Epoch [{epoch+1}/{num_epochs}], Step [{i+1}/{len(dataloader)}], Loss: {loss.item():.4f}')

print('Finished Training')
"""
        try:
            with open(train_path, "w") as f:
                f.write(train_content)
            print(f"✓ Created file: {train_path}")
        except Exception as e:
            print(f"✗ Error creating {train_path}: {e}")
            return False

        # Create notebooks directory and a starter notebook
        notebooks_dir = os.path.join(project_path, "notebooks")
        os.makedirs(notebooks_dir, exist_ok=True)
        print(f"✓ Created directory: {notebooks_dir}")

        notebook_path = os.path.join(notebooks_dir, "exploration.ipynb")
        notebook_content = {
            "cells": [
                {
                    "cell_type": "code",
                    "execution_count": None,
                    "metadata": {},
                    "outputs": [],
                    "source": [
                        "# Import libraries\n",
                        "import matplotlib.pyplot as plt\n",
                        "import numpy as np\n",
                        "from PIL import Image\n",
                        "import os\n",
                        "\n",
                        "# Example: Load and display an image\n",
                        "image_path = 'data/cat/cat_image_1.jpg' # Replace with a valid image path from your data\n",
                        "if os.path.exists(image_path):\n",
                        "    try:\n",
                        "        image = Image.open(image_path)\n",
                        "        plt.imshow(image)\n",
                        "        plt.title('Example Image')\n",
                        "        plt.axis('off')\n",
                        "        plt.show()\n",
                        "    except FileNotFoundError:\n",
                        "        print(f\"Error: The image file '{image_path}' was not found.\")\n",
                        "    except Exception as e:\n",
                        "        print(f\"An error occurred while opening the image: {e}\")\n",
                        "else:\n",
                        "    print(f\"Warning: The path '{image_path}' does not exist. Please create the data directory and a sample image.\")"
                    ]
                }
            ],
            "metadata": {
                "kernelspec": {
                    "display_name": "Python 3",
                    "language": "python",
                    "name": "python3"
                },
                "language_info": {
                    "codemirror_mode": {
                        "name": "ipython",
                        "version": 3
                    },
                    "file_extension": ".py",
                    "mimetype": "text/x-python",
                    "name": "python",
                    "nbconvert_exporter": "python",
                    "pygments_lexer": "ipython3",
                    "version": "3.x"
                }
            },
            "nbformat": 4,
            "nbformat_minor": 4
        }
        try:
            with open(notebook_path, "w") as f:
                json.dump(notebook_content, f)
            print(f"✓ Created file: {notebook_path}")
        except Exception as e:
            print(f"✗ Error creating {notebook_path}: {e}")
            return False

        # Create requirements.txt
        requirements_path = os.path.join(project_path, "requirements.txt")
        requirements_content = """
torch
torchvision
numpy
matplotlib
pillow
"""
        try:
            with open(requirements_path, "w") as f:
                f.write(requirements_content)
            print(f"✓ Created file: {requirements_path}")
        except Exception as e:
            print(f"✗ Error creating {requirements_path}: {e}")
            return False

        # Create README.md
        readme_path = os.path.join(project_path, "README.md")
        readme_content = """
# Image Classifier Project

This project demonstrates a simple image classification model using PyTorch.

## Setup

1.  Create a virtual environment: `python3 -m venv venv`
2.  Activate the virtual environment: `source venv/bin/activate`
3.  Install dependencies: `pip install -r requirements.txt`

## Data

Organize your image data into subdirectories under the `data/` directory, where each subdirectory represents a class.

## Training

Run the training script: `python src/train.py`

## Notes

*   The model architecture is defined in `src/model.py`.
*   The dataset loading logic is in `src/dataset.py`.
*   Training parameters can be adjusted in `src/train.py`.
"""
        try:
            with open(readme_path, "w") as f:
                f.write(readme_content)
            print(f"✓ Created file: {readme_path}")
        except Exception as e:
            print(f"✗ Error creating {readme_path}: {e}")
            return False

        # Create .gitignore
        gitignore_path = os.path.join(project_path, ".gitignore")
        gitignore_content = """
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
dist/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/eggs.zip
*.egg-info/
.installed.cfg
*.whl
*.tar.gz
MANIFEST

# Environments
.env
.venv
env/
venv/
ENV/
environment/
conda-meta/
# virtualenv:
venv/
.venv/

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Logs and checkpoints
*.log
*.ckpt
checkpoints/

# OS generated files
.DS_Store
Thumbs.db
"""
        try:
            with open(gitignore_path, "w") as f:
                f.write(gitignore_content)
            print(f"✓ Created file: {gitignore_path}")
        except Exception as e:
            print(f"✗ Error creating {gitignore_path}: {e}")
            return False


        print("✓ Project created successfully!")
        return True
    except Exception as e:
        print(f"✗ Error: {e}")
        return False

if __name__ == "__main__":
    main()
